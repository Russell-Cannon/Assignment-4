\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{setspace}
\usepackage{harvard}
\usepackage{listings}
\usepackage{multicol}
\bibliographystyle{apsr}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{graphicx} 
\usepackage{forest}
\usepackage{hyperref}

\begin{document}
\title{Theory and Code Task 4}
\author{Russell Cannon, Ian Mooney, Patrick Murphy}

\maketitle
\singlespacing

\begin{abstract}
\begin{center}
citations
https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/
https://www.geeksforgeeks.org/string-hashing-using-polynomial-rolling-hash-function/
\end{center}
\end{abstract}

\newpage

\section{Experimenting with occupancy ratios in linear probing}
The occupancy ratio to be used in linear probing. This involves experimenting with different values such
as 50\%, 70\%, and 80\%, and reporting runtimes in nanoseconds.

\section {Optimizing chain length in open hashing}
At least three experiments should be conducted, and runtimes
in nanoseconds should be reported.

\section{Experimentation with different hash functions}
\subsection{Simple Hash}
\begin{lstlisting}[language=C++]
static int hash(const std::string& word, int size) {
    long int hashValue = 0;

    for (char c : word) {
        hashValue += c;
    }

    return hashValue % size;
}
\end{lstlisting}

\begin{center}
Results\\
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Hash Type & Time(ms) & Lambda & \multicolumn{3}{|c|}{Chain Length/ Cluster Size} \\
 & & & Max & Min & Mean (non-zero) \\
\hline
Open & 31 & 0.705688 & 33 & 0 & 5.74652\\
Linear & 283 & 0.340332 & 5481 & 1 & 242.435\\
\hline
\end{tabular}
\end{center}

\subsection{Rabin-Karp Hash}

\begin{lstlisting}[language=C++]
static int hash(const std::string& word, int size) {
    int n = 0; // Hash value
    int d = 256; // number of characters in the input alphabet 
    for (int i = 0; i < (int)word.size(); i++)
        n = (d * n + word[i]) % size;

    return abs(n);
}
\end{lstlisting}

\begin{center}
Results\\
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Hash Type & Time(ms) & Lambda & \multicolumn{3}{|c|}{Chain Length/ Cluster Size} \\
 & & & Max & Min & Mean (non-zero) \\
\hline
Open & 40 & 0.705688 & 740 & 0 & 20.573\\
Linear & 80 & 0.340332 & 4879 & 1 & 242.435\\
\hline
\end{tabular}
\end{center}

\subsection{Polynomial Rolling Hash}

Our second attempt: (Polynomial Rolling Hash from Geeks4Geeks)
\begin{lstlisting}[language=C++]
static int hash(const std::string& word, int size) {
    int p = 31, m = 1e9 + 7, hashValue = 0, pPow = 1;

    for (char c : word) {
        hashValue = (hashValue + (c - ' ' + 1) * pPow) % m;
        pPow = (pPow * p) % m;
    }

    return abs(hashValue % size);
}
\end{lstlisting}

\begin{center}
Results\\
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Hash Type & Time(ms) & Lambda & \multicolumn{3}{|c|}{Chain Length/ Cluster Size} \\
 & & & Max & Min & Mean (non-zero) \\
\hline
Open & 46 & 0.705688 & 6 & 0 & 1.40044\\
Linear & 24 & 0.340332 & 32 & 1 & 1.79491\\
\hline
\end{tabular}
\end{center}

\subsection{Polynomial Rolling Hash With Reduced Alphabet}

third attempt: (maps only the characters we allow)
\begin{lstlisting}[language=C++]
static int charToIndex(const char c) {
    //-, a, b, ..., z, 0, 1, ... 9
    if (c == '-') return 1;
    if (c == '\'') return 2;
    if (std::isalpha(c)) return c - 'a' + 3;
    if (std::isdigit(c)) return c - '0' + 26 + 4;
    return 0;
}

static int hash(const std::string& word, int size) {
    int p = 31;
    long int m = 1e9 + 7, hashValue = 0, pPow = 1;

    for (char c : word) {
        hashValue = (hashValue + charToIndex(c) * pPow) % m;
        pPow = (pPow * p) % m;
    }

    return hashValue % size;
}
\end{lstlisting}

\begin{center}
Results\\
\begin{tabular}{|c|c|c|c|c|c|}
\hline
Hash Type & Time(ms) & Lambda & \multicolumn{3}{|c|}{Chain Length/ Cluster Size} \\
 & & & Max & Min & Mean (non-zero) \\
\hline
Open & 26 & 0.705688 & 5 & 0 & 1.389\\
Linear & 21 & 0.340332 & 14 & 1 & 1.80804\\
\hline
\end{tabular}
\end{center}

\section{Handling collisions in the table for linear probing}
Handling collisions in the table for linear probing. The collision resolution method implemented must be
described, with research and inclusion of a method described in the lecture.

\subsection{Linear}
\begin{lstlisting}[language=C++]
int index = hash(pair.word, size);
while (!arr[index].empty && arr[index].word != pair.word) {
    index = (index + 1) % size;
}
\end{lstlisting}

\subsection{Double Hash}
\begin{lstlisting}[language=C++]
int index = hash(pair.word, size);
while (!arr[index].empty && arr[index].word != pair.word) {
    index = (index + hash(index, size)) % size;
}
\end{lstlisting}

\section{Rabin-Karp}
Writing a function to prompt a user for a word, display the number of occurrences of this word in the
text, and the locations of said occurrences in “The Adventure of the Engineer’s Thumb”.

\section{80 Least and most frequent words}
Implementing a function to output a list of the 80 least frequently occurring words in the text.

Implementing a function to output a list of the 80 most frequently occurring words in the text.

\end{document}